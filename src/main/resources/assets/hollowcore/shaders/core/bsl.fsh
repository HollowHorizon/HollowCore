#version 330 core
// Generated by glsl-transformer
#extension GL_ARB_shader_texture_lod: enable

uniform mat4 iris_ProjMat;
uniform mat4 iris_ModelViewMatInverse;
uniform mat4 iris_ProjMatInverse;
uniform mat3 iris_NormalMat;
uniform mat4 iris_LightmapTextureMatrix;
uniform mat4 iris_TextureMat;
uniform mat4 iris_ModelViewMat;
uniform vec4 iris_ColorModulator;
uniform float iris_FogDensity;
uniform float iris_FogStart;
uniform float iris_FogEnd;
uniform vec4 iris_FogColor;

struct iris_FogParameters {
    vec4 color;
    float density;
    float start;
    float end;
    float scale;
};

iris_FogParameters iris_Fog = iris_FogParameters(iris_FogColor, iris_FogDensity, iris_FogStart, iris_FogEnd, 1.0f / (iris_FogEnd - iris_FogStart));

uniform float iris_currentAlphaTest;

layout(location = 3) out vec4 iris_FragData3;
layout(location = 2) out vec4 iris_FragData2;
layout(location = 1) out vec4 iris_FragData1;
layout(location = 0) out vec4 iris_FragData0;

in float iris_FogFragCoord;
flat in ivec3 iris_entityInfo;
in vec4 entityColor;
in vec4 iris_vertexColor;

const int shadowMapResolution = 2048;
const float shadowDistance = 256.0f;
const float sunPathRotation = -40.0f;
const float shadowMapBias = 1.0f - 25.6f / shadowDistance;

in vec2 texCoord, lmCoord;
in vec3 normal;
in vec3 sunVec, upVec, eastVec;
in vec4 color;
in float dist;
in vec3 binormal, tangent;
in vec3 viewVector;
in vec4 vTexCoord, vTexCoordAM;

uniform int frameCounter;
uniform int isEyeInWater;
uniform int worldTime;
uniform float frameTimeCounter;
uniform float nightVision;
uniform float rainStrength;
uniform float screenBrightness;
uniform float shadowFade;
uniform float timeAngle, timeBrightness;
uniform float viewWidth, viewHeight;
uniform ivec2 eyeBrightnessSmooth;
uniform vec3 cameraPosition;
uniform mat4 gbufferProjectionInverse;
uniform mat4 gbufferModelViewInverse;
uniform mat4 shadowProjection;
uniform mat4 shadowModelView;
uniform sampler2D gtexture;
uniform ivec2 atlasSize;
uniform sampler2D specular;
uniform sampler2D normals;

float eBS = eyeBrightnessSmooth.y / 240.0f;
float sunVisibility = clamp((dot(sunVec, upVec) + 0.05f) * 10.0f, 0.0f, 1.0f);
float moonVisibility = clamp((dot(-sunVec, upVec) + 0.05f) * 10.0f, 0.0f, 1.0f);
float frametime = frameTimeCounter * 1.0f;
vec2 dcdx = dFdx(texCoord);
vec2 dcdy = dFdy(texCoord);
vec3 lightVec = sunVec * ((timeAngle < 0.5325f || timeAngle > 0.9675f) ? 1.0f : -1.0f);
float GetLuminance(vec3 color) {
    return dot(color, vec3(0.299f, 0.587f, 0.114f));
}

vec3 blocklightColSqrt = vec3(255, 212, 160) * 0.85f / 255.0f;
vec3 blocklightCol = blocklightColSqrt * blocklightColSqrt;
vec3 lightMorning = vec3(255, 160, 80) * 1.2f / 255.0f;
vec3 lightDay = vec3(196, 220, 255) * 1.4f / 255.0f;
vec3 lightEvening = vec3(255, 160, 80) * 1.2f / 255.0f;
vec3 lightNight = vec3(96, 192, 255) * 1.0f * 0.3f / 255.0f;
vec3 ambientMorning = vec3(255, 204, 144) * 0.35f / 255.0f;
vec3 ambientDay = vec3(120, 172, 255) * 0.6f / 255.0f;
vec3 ambientEvening = vec3(255, 204, 144) * 0.35f / 255.0f;
vec3 ambientNight = vec3(96, 192, 255) * 0.6f * 0.3f / 255.0f;

uniform float isDesert, isMesa, isCold, isSwamp, isMushroom, isSavanna, isJungle;

vec4 weatherRain = vec4(vec3(176, 224, 255) / 255.0f, 1.0f) * 1.2f;
vec4 weatherCold = vec4(vec3(216, 240, 255) / 255.0f, 1.0f) * 1.2f;
vec4 weatherDesert = vec4(vec3(255, 232, 180) / 255.0f, 1.0f) * 1.2f;
vec4 weatherBadlands = vec4(vec3(255, 216, 176) / 255.0f, 1.0f) * 1.2f;
vec4 weatherSwamp = vec4(vec3(200, 224, 160) / 255.0f, 1.0f) * 1.2f;
vec4 weatherMushroom = vec4(vec3(216, 216, 255) / 255.0f, 1.0f) * 1.2f;
vec4 weatherSavanna = vec4(vec3(224, 224, 224) / 255.0f, 1.0f) * 1.2f;
vec4 weatherJungle = vec4(vec3(176, 232, 232) / 255.0f, 1.0f) * 1.2f;
float weatherWeight = isCold + isDesert + isMesa + isSwamp + isMushroom + isSavanna + isJungle;
vec4 weatherCol = mix(weatherRain, (weatherCold * isCold + weatherDesert * isDesert + weatherBadlands * isMesa + weatherSwamp * isSwamp + weatherMushroom * isMushroom + weatherSavanna * isSavanna + weatherJungle * isJungle) / max(weatherWeight, 1.0E-4f), weatherWeight);
float mefade = 1.0f - clamp(abs(timeAngle - 0.5f) * 8.0f - 1.5f, 0.0f, 1.0f);
float dfade = 1.0f - pow(1.0f - timeBrightness, 1.5f);
vec3 lightSun = mix(mix(lightMorning, lightEvening, mefade), lightDay, dfade);
vec3 ambientSun = mix(mix(ambientMorning, ambientEvening, mefade), ambientDay, dfade);
vec3 lightColRaw = mix(lightNight, lightSun, sunVisibility);
vec3 lightColSqrt = mix(lightColRaw, dot(lightColRaw, vec3(0.299f, 0.587f, 0.114f)) * weatherCol.rgb, rainStrength);
vec3 lightCol = lightColSqrt * lightColSqrt;
vec3 ambientColRaw = mix(ambientNight, ambientSun, sunVisibility);
vec3 ambientColSqrt = mix(ambientColRaw, dot(ambientColRaw, vec3(0.299f, 0.587f, 0.114f)) * weatherCol.rgb, rainStrength);
vec3 ambientCol = ambientColSqrt * ambientColSqrt;
vec3 minLightColSqrt = vec3(128, 128, 128) * 0.7f / 255.0f;
vec3 minLightCol = minLightColSqrt * minLightColSqrt * 0.04f;

vec3 GetMetalCol(float f0) {
    int metalidx = int(f0 * 255.0f);
    if (metalidx == 230) return vec3(0.24867f, 0.22965f, 0.21366f);
    if (metalidx == 231) return vec3(0.8814f, 0.57256f, 0.1145f);
    if (metalidx == 232) return vec3(0.81715f, 0.82021f, 0.83177f);
    if (metalidx == 233) return vec3(0.27446f, 0.2733f, 0.27357f);
    if (metalidx == 234) return vec3(0.8443f, 0.48677f, 0.22164f);
    if (metalidx == 235) return vec3(0.36501f, 0.35675f, 0.37653f);
    if (metalidx == 236) return vec3(0.42648f, 0.37772f, 0.31138f);
    if (metalidx == 237) return vec3(0.9183f, 0.89219f, 0.83662f);
    return vec3(1.0f);
}

vec3 GetSpecularColor(float skylight, float metalness, vec3 baseReflectance) {
    vec3 specularColor = vec3(0.0f);
    vec3 lightME = mix(lightMorning, lightEvening, mefade);
    vec3 lightDaySpec = mix(sqrt(lightME), sqrt(lightDay), dfade * 0.7f);
    vec3 lightNightSpec = sqrt(lightNight * 1.0f * 0.2f);
    specularColor = mix(lightNightSpec, lightDaySpec * lightDaySpec, sunVisibility);
    specularColor *= specularColor * skylight;
    specularColor = pow(specularColor, vec3(1.0f - 0.5f * metalness)) * pow(max(length(specularColor), 1.0E-4f), 0.5f * metalness);
    return specularColor;
}

vec3 ToNDC(vec3 pos) {
    vec4 iProjDiag = vec4(gbufferProjectionInverse[0].x, gbufferProjectionInverse[1].y, gbufferProjectionInverse[2].zw);
    vec3 p3 = pos * 2.0f - 1.0f;
    vec4 viewPos = iProjDiag * p3.xyzz + gbufferProjectionInverse[3];
    return viewPos.xyz / viewPos.w;
}

vec3 ToWorld(vec3 pos) {
    return mat3(gbufferModelViewInverse) * pos + gbufferModelViewInverse[3].xyz;
}

vec3 ToShadow(vec3 pos) {
    vec3 shadowpos = mat3(shadowModelView) * pos + shadowModelView[3].xyz;
    return (vec3((shadowProjection)[0].x, (shadowProjection)[1].y, shadowProjection[2].z) * (shadowpos) + (shadowProjection)[3].xyz);
}

uniform sampler2DShadow shadowtex0;
uniform sampler2DShadow shadowtex1;
uniform sampler2D shadowcolor0;

vec2 shadowOffsets[9] = vec2[9](vec2(0.0f, 0.0f), vec2(0.0f, 1.0f), vec2(0.7f, 0.7f), vec2(1.0f, 0.0f), vec2(0.7f, -0.7f), vec2(0.0f, -1.0f), vec2(-0.7f, -0.7f), vec2(-1.0f, 0.0f), vec2(-0.7f, 0.7f));
float biasDistribution[10] = float[10](0.0f, 0.057f, 0.118f, 0.184f, 0.255f, 0.333f, 0.423f, 0.529f, 0.667f, 1.0f);

vec3 DistortShadow(vec3 worldPos, float distortFactor) {
    worldPos.xy /= distortFactor;
    worldPos.z *= 0.2f;
    return worldPos * 0.5f + 0.5f;
}

float InterleavedGradientNoise() {
    float n = 52.9829189f * fract(0.06711056f * gl_FragCoord.x + 0.00583715f * gl_FragCoord.y);
    return fract(n + frameCounter * 1.618f);
}

vec3 SampleFilteredShadow(vec3 shadowPos, float offset, float biasStep, float subsurface) {
    float shadow0 = 0.0f;
    for (int i = 0; i < 9; i++) {
        vec2 shadowOffset = shadowOffsets[i] * offset;
        shadow0 += vec4(texture(shadowtex0, vec3(shadowPos.st + shadowOffset, shadowPos.z))).x;
    }
    shadow0 /= 9.0f;
    vec3 shadowCol = vec3(0.0f);
    if (shadow0 < 0.999f) {
        for (int i = 0; i < 9; i++) {
            vec2 shadowOffset = shadowOffsets[i] * offset;
            vec3 shadowColSample = texture(shadowcolor0, shadowPos.st + shadowOffset).rgb * vec4(texture(shadowtex1, vec3(shadowPos.st + shadowOffset, shadowPos.z))).x;
            shadowCol += shadowColSample;
        }
        shadowCol /= 9.0f;
    }
    shadow0 *= mix(shadow0, 1.0f, subsurface);
    shadowCol *= shadowCol;
    return clamp(shadowCol * (1.0f - shadow0) + shadow0, vec3(0.0f), vec3(16.0f));
}

vec3 GetShadow(vec3 worldPos, vec3 normal, float NoL, float subsurface, float skylight) {
    vec3 shadowPos = ToShadow(worldPos);
    float distb = sqrt(dot(shadowPos.xy, shadowPos.xy));
    float distortFactor = distb * shadowMapBias + (1.0f - shadowMapBias);
    shadowPos = DistortShadow(shadowPos, distortFactor);
    bool doShadow = shadowPos.x > 0.0f && shadowPos.x < 1.0f && shadowPos.y > 0.0f && shadowPos.y < 1.0f;
    doShadow = doShadow && skylight > 0.001f;
    float skylightShadow = smoothstep(0.866f, 1.0f, skylight);
    if (!doShadow) return vec3(skylightShadow);
    float bias = 0.0f;
    float offset = 1.0f / shadowMapResolution;
    float biasFactor = sqrt(1.0f - NoL * NoL) / NoL;
    float distortBias = distortFactor * shadowDistance / 256.0f;
    distortBias *= 8.0f * distortBias;
    float distanceBias = sqrt(dot(worldPos.xyz, worldPos.xyz)) * 0.005f;
    bias = (distortBias * biasFactor + distanceBias + 0.05f) / shadowMapResolution;
    if (subsurface > 0.0f) {
        bias = 2.0E-4f;
        offset = 7.0E-4f;
    }
    float biasStep = 0.001f * subsurface * (1.0f - NoL);
    shadowPos.z -= bias;
    vec3 shadow = SampleFilteredShadow(shadowPos, offset, biasStep, subsurface);
    return shadow;
}

vec3 GetSubsurfaceShadow(vec3 worldPos, float subsurface, float skylight) {
    float gradNoise = InterleavedGradientNoise();
    vec3 shadowPos = ToShadow(worldPos);
    float distb = sqrt(dot(shadowPos.xy, shadowPos.xy));
    float distortFactor = distb * shadowMapBias + (1.0f - shadowMapBias);
    shadowPos = DistortShadow(shadowPos, distortFactor);
    vec3 subsurfaceShadow = vec3(0.0f);
    for (int i = 0; i < 12; i++) {
        gradNoise = fract(gradNoise + 1.618f);
        float rot = gradNoise * 6.283f;
        float dist = (i + gradNoise) / 12.0f;
        vec2 offset2D = vec2(cos(rot), sin(rot)) * dist;
        float offsetZ = -(dist * dist + 0.025f);
        vec3 offsetScale = vec3(0.002f / distortFactor, 0.002f / distortFactor, 0.001f);
        vec3 lowOffset = vec3(0.0f, 0.0f, -2.5E-4f * (1.0f + gradNoise) * distortFactor);
        vec3 highOffset = vec3(offset2D, offsetZ) * offsetScale;
        vec3 offset = highOffset * (subsurface * 0.75f + 0.25f);
        vec3 samplePos = shadowPos + offset;
        float shadow0 = vec4(texture(shadowtex0, samplePos)).x;
        vec3 shadowCol = vec3(0.0f);
        if (shadow0 < 1.0f) {
            shadowCol = texture(shadowcolor0, samplePos.st).rgb * vec4(texture(shadowtex1, samplePos)).x;
        }
        subsurfaceShadow += clamp(shadowCol * (1.0f - shadow0) + shadow0, vec3(0.0f), vec3(1.0f));
    }
    subsurfaceShadow /= 12.0f;
    subsurfaceShadow *= subsurfaceShadow;
    return subsurfaceShadow;
}

void GetLighting(
    inout vec3 albedo,
    out vec3 shadow,
    vec3 viewPos,
    vec3 worldPos,
    vec3 normal,
    vec2 lightmap,
    float smoothLighting,
    float NoL,
    float vanillaDiffuse,
    float parallaxShadow,
    float emission,
    float subsurface,
    float basicSubsurface
) {
    if (NoL > 0.0f || basicSubsurface > 0.0f) {
        shadow = GetShadow(worldPos, normal, NoL, basicSubsurface, lightmap.y);
    }
    shadow *= parallaxShadow;
    shadow = max(shadow, vec3(0.0f));
    NoL = clamp(NoL * 1.01f - 0.01f, 0.0f, 1.0f);
    float scattering = 0.0f;
    if (basicSubsurface > 0.0f) {
        float VoL = clamp(dot(normalize(viewPos.xyz), lightVec) * 0.5f + 0.5f, 0.0f, 1.0f);
        scattering = pow(VoL, 16.0f) * (1.0f - rainStrength) * basicSubsurface * shadowFade;
        NoL = mix(NoL, 1.0f, sqrt(basicSubsurface) * 0.7f);
        NoL = mix(NoL, 1.0f, scattering);
    }
    vec3 fullShadow = max(shadow * NoL, vec3(0.0f));
    if (subsurface > 0.0f) {
        vec3 subsurfaceShadow = GetSubsurfaceShadow(worldPos, subsurface, lightmap.y);
        float VoL = clamp(dot(normalize(viewPos.xyz), lightVec) * 0.5f + 0.5f, 0.0f, 1.0f);
        float scattering = pow(VoL, 16.0f) * (1.0f - rainStrength) * shadowFade;
        vec3 subsurfaceColor = normalize(albedo + 1.0E-5f) * 1.2f;
        subsurfaceColor = mix(subsurfaceColor, vec3(1.0f), pow(subsurfaceShadow, vec3(4.0f)));
        subsurfaceColor = mix(subsurfaceColor, vec3(4.0f), scattering) * sqrt(subsurface);
        fullShadow = mix(subsurfaceColor * subsurfaceShadow, vec3(1.0f), fullShadow);
    }
    float shadowMult = (1.0f - 0.95f * rainStrength) * shadowFade;
    vec3 sceneLighting = mix(ambientCol * lightmap.y, lightCol, fullShadow * shadowMult);
    sceneLighting *= lightmap.y * lightmap.y * (1.0f + scattering * shadow);
    float newLightmap = pow(lightmap.x, 10.0f) * 1.6f + lightmap.x * 0.6f;
    vec3 blockLighting = blocklightCol * newLightmap * newLightmap;
    vec3 minLighting = minLightCol * (1.0f - lightmap.y * lightmap.y);
    vec3 albedoNormalized = normalize(albedo.rgb + 1.0E-5f);
    vec3 emissiveLighting = mix(albedoNormalized, vec3(1.0f), emission * 0.5f);
    emissiveLighting *= emission * 4.0f;
    float lightFlatten = clamp(1.0f - pow(1.0f - emission, 128.0f), 0.0f, 1.0f);
    vanillaDiffuse = mix(vanillaDiffuse, 1.0f, lightFlatten);
    smoothLighting = mix(smoothLighting, 1.0f, lightFlatten);
    float nightVisionLighting = nightVision * 0.25f;
    float albedoLength = length(albedo.rgb);
    albedoLength /= sqrt((albedoLength * albedoLength) * 0.25f * (1.0f - lightFlatten) + 1.0f);
    albedo.rgb = albedoNormalized * albedoLength;
    albedo *= max(sceneLighting + blockLighting + emissiveLighting + nightVisionLighting + minLighting, vec3(0.0f));
    albedo *= vanillaDiffuse * smoothLighting * smoothLighting;
    float desatAmount = 1.0f - sqrt(max(sqrt(length(fullShadow / 3.0f)) * lightmap.y, lightmap.y)) * sunVisibility * (1.0f - rainStrength * 0.7f);
    desatAmount *= smoothstep(0.25f, 1.0f, (1.0f - lightmap.x) * (1.0f - lightmap.x)) * (1.0f - lightFlatten);
    desatAmount = 1.0f - desatAmount;
    vec3 desatNight = normalize(lightNight * lightNight + 1.0E-6f);
    vec3 desatWeather = normalize(weatherCol.rgb * weatherCol.rgb + 1.0E-6f);
    float desatNWMix = (1.0f - sunVisibility) * (1.0f - rainStrength);
    vec3 desatColor = mix(desatWeather, desatNight, desatNWMix);
    desatColor = mix(vec3(0.4f), desatColor, sqrt(lightmap.y)) * 1.7f;
    vec3 desatAlbedo = mix(albedo, GetLuminance(albedo) * desatColor, 1.0f - 1.5f * 0.4f);
    albedo = mix(desatAlbedo, albedo, desatAmount);
}

float GetNoHSquared(float radiusTan, float NoL, float NoV, float VoL) {
    float radiusCos = 1.0f / sqrt(1.0f + radiusTan * radiusTan);
    float RoL = 2.0f * NoL * NoV - VoL;
    if (RoL >= radiusCos) return 1.0f;
    float rOverLengthT = radiusCos * radiusTan / sqrt(1.0f - RoL * RoL);
    float NoTr = rOverLengthT * (NoV - RoL * NoL);
    float VoTr = rOverLengthT * (2.0f * NoV * NoV - 1.0f - RoL * VoL);
    float triple = sqrt(clamp(1.0f - NoL * NoL - NoV * NoV - VoL * VoL + 2.0f * NoL * NoV * VoL, 0.0f, 1.0f));
    float NoBr = rOverLengthT * triple, VoBr = rOverLengthT * (2.0f * triple * NoV);
    float NoLVTr = NoL * radiusCos + NoV + NoTr, VoLVTr = VoL * radiusCos + 1.0f + VoTr;
    float p = NoBr * VoLVTr, q = NoLVTr * VoLVTr, s = VoBr * NoLVTr;
    float xNum = q * (-0.5f * p + 0.25f * VoBr * NoLVTr);
    float xDenom = p * p + s * (s - 2.0f * p) + NoLVTr * ((NoL * radiusCos + NoV) * VoLVTr * VoLVTr + q * (-0.5f * (VoLVTr + VoL * radiusCos) - 0.5f));
    float twoX1 = 2.0f * xNum / (xDenom * xDenom + xNum * xNum);
    float sinTheta = twoX1 * xDenom;
    float cosTheta = 1.0f - twoX1 * xNum;
    NoTr = cosTheta * NoTr + sinTheta * NoBr;
    VoTr = cosTheta * VoTr + sinTheta * VoBr;
    float newNoL = NoL * radiusCos + NoTr;
    float newVoL = VoL * radiusCos + VoTr;
    float NoH = NoV + newNoL;
    float HoH = 2.0f * newVoL + 2.0f;
    return clamp(NoH * NoH / HoH, 0.0f, 1.0f);
}

float GGXTrowbridgeReitz(float NoHsqr, float roughness) {
    float roughnessSqr = roughness * roughness;
    float distr = NoHsqr * (roughnessSqr - 1.0f) + 1.0f;
    return roughnessSqr / (3.14159f * distr * distr);
}

float SchlickGGX(float NoL, float NoV, float roughness) {
    float k = roughness * 0.5f;
    float smithL = 0.5f / (NoL * (1.0f - k) + k);
    float smithV = 0.5f / (NoV * (1.0f - k) + k);
    return smithL * smithV;
}

vec3 SphericalGaussianFresnel(float HoL, vec3 baseReflectance) {
    float fresnel = exp2(((-5.55473f * HoL) - 6.98316f) * HoL);
    return fresnel * (1.0f - baseReflectance) + baseReflectance;
}

vec3 GGX(vec3 normal, vec3 viewPos, float smoothness, vec3 baseReflectance, float sunSize) {
    float roughness = max(1.0f - smoothness, 0.025f);
    roughness *= roughness;
    viewPos = -viewPos;
    vec3 halfVec = normalize(lightVec + viewPos);
    float HoL = clamp(dot(halfVec, lightVec), 0.0f, 1.0f);
    float NoL = clamp(dot(normal, lightVec), 0.0f, 1.0f);
    float NoV = clamp(dot(normal, viewPos), -1.0f, 1.0f);
    float VoL = dot(lightVec, viewPos);
    float NoHsqr = GetNoHSquared(sunSize, NoL, NoV, VoL);
    if (NoV < 0.0f) {
        NoHsqr = dot(normal, halfVec);
        NoHsqr *= NoHsqr;
    }
    NoV = max(NoV, 0.0f);
    float D = GGXTrowbridgeReitz(NoHsqr, roughness);
    vec3 F = SphericalGaussianFresnel(HoL, baseReflectance);
    float G = SchlickGGX(NoL, NoV, roughness);
    float Fl = max(length(F), 0.001f);
    vec3 Fn = F / Fl;
    float specular = D * Fl * G;
    vec3 specular3 = specular / (1.0f + 0.03125f / 4.0f * specular) * Fn * NoL;
    specular3 *= 1.0f - roughness * roughness;
    return specular3;
}

vec3 GetSpecularHighlight(
    vec3 normal,
    vec3 viewPos,
    float smoothness,
    vec3 baseReflectance,
    vec3 specularColor,
    vec3 shadow,
    float smoothLighting
) {
    if (dot(shadow, shadow) < 1.0E-5f) return vec3(0.0f);
    if (smoothness < 2.0E-5f) return vec3(0.0f);
    smoothLighting *= smoothLighting;
    vec3 specular = GGX(normal, normalize(viewPos), smoothness, baseReflectance, (0.025f * sunVisibility + 0.05f) * 1.0f);
    specular *= shadow * shadowFade * smoothLighting;
    specular *= (1.0f - rainStrength) * (1.0f - rainStrength);
    return specular * specularColor;
}

vec2 EncodeNormal(vec3 n) {
    float f = sqrt(n.z * 8.0f + 8.0f);
    return n.xy / f + 0.5f;
}

vec3 GetN(int idx) {
    if (idx == 230) return vec3(2.9114f, 2.9497f, 2.5845f);
    if (idx == 231) return vec3(0.18299f, 0.42108f, 1.3734f);
    if (idx == 232) return vec3(1.3456f, 0.96521f, 0.61722f);
    if (idx == 233) return vec3(3.1071f, 3.1812f, 2.323f);
    if (idx == 234) return vec3(0.27105f, 0.67693f, 1.3164f);
    if (idx == 235) return vec3(1.91f, 1.83f, 1.44f);
    if (idx == 236) return vec3(2.3757f, 2.0847f, 1.8453f);
    if (idx == 237) return vec3(0.15943f, 0.14512f, 0.13547f);
    return vec3(0.0f);
}

vec3 GetK(int idx) {
    if (idx == 230) return vec3(3.0893f, 2.9318f, 2.767f);
    if (idx == 231) return vec3(3.4242f, 2.3459f, 1.7704f);
    if (idx == 232) return vec3(7.4746f, 6.3995f, 5.3031f);
    if (idx == 233) return vec3(3.3314f, 3.3291f, 3.135f);
    if (idx == 234) return vec3(3.6092f, 2.6248f, 2.2921f);
    if (idx == 235) return vec3(3.51f, 3.4f, 3.18f);
    if (idx == 236) return vec3(4.2655f, 3.7153f, 3.1365f);
    if (idx == 237) return vec3(3.9291f, 3.19f, 2.3808f);
    return vec3(1.0f);
}

vec3 ComplexFresnel(float fresnel, float f0) {
    int metalidx = int(f0 * 255.0f);
    vec3 k = GetK(metalidx);
    vec3 n = GetN(metalidx);
    float f = 1.0f - fresnel;
    vec3 k2 = k * k;
    vec3 n2 = n * n;
    float f2 = f * f;
    vec3 rs_num = n2 + k2 - 2 * n * f + f2;
    vec3 rs_den = n2 + k2 + 2 * n * f + f2;
    vec3 rs = rs_num / rs_den;
    vec3 rp_num = (n2 + k2) * f2 - 2 * n * f + 1;
    vec3 rp_den = (n2 + k2) * f2 + 2 * n * f + 1;
    vec3 rp = rp_num / rp_den;
    vec3 fresnel3 = clamp(0.5f * (rs + rp), vec3(0.0f), vec3(1.0f));
    fresnel3 *= fresnel3;
    return fresnel3;
}

void GetMaterials(
    out float smoothness,
    out float metalness,
    out float f0,
    inout float emission,
    inout float subsurface,
    out float porosity,
    out float ao,
    out vec3 normalMap,
    vec2 newCoord,
    vec2 dcdx,
    vec2 dcdy
) {
    vec4 specularMap = textureLod(specular, newCoord, 0);
    smoothness = specularMap.r;
    f0 = specularMap.g;
    metalness = f0 >= 0.9f ? 1.0f : 0.0f;
    float emissionMat = specularMap.a < 1.0f ? clamp(specularMap.a * 1.004f - 0.004f, 0.0f, 1.0f) : 0.0f;
    emissionMat *= emissionMat;
    porosity = specularMap.b <= 0.251f ? specularMap.b * 3.984f : 0.0f;
    subsurface = specularMap.b > 0.251f ? clamp(specularMap.b * 1.335f - 0.355f, 0.0f, 1.0f) : 0.0f;
    normalMap = vec3(textureGrad(normals, newCoord, dcdx, dcdy).xy, 0.0f) * 2.0f - 1.0f;
    ao = textureGrad(normals, newCoord, dcdx, dcdy).z;
    if (normalMap.x + normalMap.y > -1.999f) {
        if (length(normalMap.xy) > 1.0f) normalMap.xy = normalize(normalMap.xy);
        normalMap.z = sqrt(1.0f - dot(normalMap.xy, normalMap.xy));
        normalMap = normalize(clamp(normalMap, vec3(-1.0f), vec3(1.0f)));
    }
    else {
        normalMap = vec3(0.0f, 0.0f, 1.0f);
        ao = 1.0f;
    }
    emission = mix(emissionMat, 1.0f, emission);
    vec2 mipx = dcdx * atlasSize;
    vec2 mipy = dcdy * atlasSize;
    float delta = max(dot(mipx, mipx), dot(mipy, mipy));
    float miplevel = max(0.25f * log2(delta), 0.0f);
    normalMap = normalize(mix(vec3(0.0f, 0.0f, 1.0f), normalMap, 1.0f / exp2(miplevel)));
}

vec4 ReadNormal(vec2 coord) {
    coord = fract(coord) * vTexCoordAM.pq + vTexCoordAM.st;
    return textureGrad(normals, coord, dcdx, dcdy);
}

vec2 GetParallaxCoord(vec2 texCoord, float parallaxFade, out float surfaceDepth) {
    vec2 coord = vTexCoord.st;
    surfaceDepth = 1.0f;
    if (viewVector != viewVector) {
        return texCoord;
    }
    float sampleStep = 1.0f / 128;
    float currentStep = 1.0f;
    vec2 scaledDir = viewVector.xy * 0.2f / -viewVector.z;
    vec2 stepDir = scaledDir * sampleStep * (1.0f - parallaxFade);
    vec3 normalMap = ReadNormal(coord).xyz * 2.0f - 1.0f;
    float normalCheck = normalMap.x + normalMap.y;
    if (parallaxFade >= 1.0f || normalCheck < -1.999f) return texCoord;
    float depth = ReadNormal(coord).a;
    for (int i = 0; i < 128; i++) {
        if (currentStep <= depth) break;
        coord += stepDir;
        depth = ReadNormal(coord).a;
        currentStep -= sampleStep;
    }
    coord = fract(coord.st) * vTexCoordAM.pq + vTexCoordAM.st;
    surfaceDepth = currentStep;
    return coord;
}

float GetParallaxShadow(float surfaceDepth, float parallaxFade, vec2 coord, vec3 lightVec, mat3 tbn) {
    float parallaxshadow = 1.0f;
    if (parallaxFade >= 1.0f) return 1.0f;
    float height = surfaceDepth;
    if (height > 1.0f - 0.5f / 128) return 1.0f;
    vec3 parallaxdir = tbn * lightVec;
    parallaxdir.xy *= 0.2f * 2.0f;
    vec2 newvTexCoord = (coord - vTexCoordAM.st) / vTexCoordAM.pq;
    float sampleStep = 0.32f / 8;
    vec2 ptexCoord = fract(newvTexCoord + parallaxdir.xy * sampleStep) * vTexCoordAM.pq + vTexCoordAM.st;
    float texHeight = textureGrad(normals, coord, dcdx, dcdy).a;
    float texHeightOffset = textureGrad(normals, ptexCoord, dcdx, dcdy).a;
    float texFactor = clamp((height - texHeightOffset) / sampleStep + 1.0f, 0.0f, 1.0f);
    height = mix(height, texHeight, texFactor);
    for (int i = 0; i < 8; i++) {
        float currentHeight = height + parallaxdir.z * sampleStep * i;
        vec2 parallaxCoord = fract(newvTexCoord + parallaxdir.xy * i * sampleStep) * vTexCoordAM.pq + vTexCoordAM.st;
        float offsetHeight = textureGrad(normals, parallaxCoord, dcdx, dcdy).a;
        float sampleShadow = clamp(1.0f - (offsetHeight - currentHeight) * 16, 0.0f, 1.0f);
        parallaxshadow = min(parallaxshadow, sampleShadow);
        if (parallaxshadow < 0.01f) break;
    }
    parallaxshadow *= parallaxshadow;
    parallaxshadow = mix(parallaxshadow, 1.0f, parallaxFade);
    return parallaxshadow;
}

void main() {
    float iris_vertexColorAlpha = iris_vertexColor.a;
    vec4 albedo = texture(gtexture, texCoord) * color;
    vec3 newNormal = normal;
    float smoothness = 0.0f;
    vec2 newCoord = vTexCoord.st * vTexCoordAM.pq + vTexCoordAM.st;
    float surfaceDepth = 1.0f;
    float parallaxFade = clamp((dist - 64) / 32.0f, 0.0f, 1.0f);
    float skipAdvMat = float(iris_entityInfo.x == 10100);
    if (skipAdvMat < 0.5f) {
        newCoord = GetParallaxCoord(texCoord, parallaxFade, surfaceDepth);
        albedo = textureGrad(gtexture, newCoord, dcdx, dcdy) * color;
    }
    float skyOcclusion = 0.0f;
    vec3 fresnel3 = vec3(0.0f);
    albedo.rgb = mix(albedo.rgb, entityColor.rgb, entityColor.a);
    float lightningBolt = float(iris_entityInfo.x == 10101);
    if (lightningBolt > 0.5f) {
        albedo.rgb = weatherCol.rgb / weatherCol.a;
        albedo.rgb *= albedo.rgb * albedo.rgb;
        albedo.a = 1.0f;
    }
    if (albedo.a > 0.001f && lightningBolt < 0.5f) {
        vec2 lightmap = clamp(lmCoord, vec2(0.0f), vec2(1.0f));
        float metalness = 0.0f;
        float emission = float(entityColor.a > 0.05f) * 0.125f;
        float subsurface = 0.0f;
        vec3 baseReflectance = vec3(0.04f);
        emission *= dot(albedo.rgb, albedo.rgb) * 0.333f;
        vec3 screenPos = vec3(gl_FragCoord.xy / vec2(viewWidth, viewHeight), gl_FragCoord.z);
        vec3 viewPos = ToNDC(screenPos);
        vec3 worldPos = ToWorld(viewPos);
        float f0 = 0.0f, porosity = 0.5f, ao = 1.0f;
        vec3 normalMap = vec3(0.0f, 0.0f, 1.0f);
        GetMaterials(smoothness, metalness, f0, emission, subsurface, porosity, ao, normalMap, newCoord, dcdx, dcdy);
        mat3 tbnMatrix = mat3(tangent.x, binormal.x, normal.x, tangent.y, binormal.y, normal.y, tangent.z, binormal.z, normal.z);
        if ((normalMap.x > -0.999f || normalMap.y > -0.999f) && viewVector == viewVector && skipAdvMat < 0.5f) newNormal = clamp(normalize(normalMap * tbnMatrix), vec3(-1.0f), vec3(1.0f));
        albedo.rgb = pow(albedo.rgb, vec3(2.2f));
        float NoL = clamp(dot(newNormal, lightVec), 0.0f, 1.0f);
        float NoU = clamp(dot(newNormal, upVec), -1.0f, 1.0f);
        float NoE = clamp(dot(newNormal, eastVec), -1.0f, 1.0f);
        float vanillaDiffuse = (0.25f * NoU + 0.75f) + (0.667f - abs(NoE)) * (1.0f - abs(NoU)) * 0.15f;
        vanillaDiffuse *= vanillaDiffuse;
        float parallaxShadow = 1.0f;
        vec3 rawAlbedo = albedo.rgb * 0.999f + 0.001f;
        albedo.rgb *= ao;
        albedo.rgb *= 1.0f - metalness * smoothness;
        float doParallax = 0.0f;
        doParallax = float(lightmap.y > 0.0f && NoL > 0.0f);
        if (doParallax > 0.5f) {
            parallaxShadow = GetParallaxShadow(surfaceDepth, parallaxFade, newCoord, lightVec, tbnMatrix);
        }
        vec3 shadow = vec3(0.0f);
        GetLighting(albedo.rgb, shadow, viewPos, worldPos, normal, lightmap, 1.0f, NoL, vanillaDiffuse, parallaxShadow, emission, subsurface, 0.0f);
        skyOcclusion = lightmap.y;
        baseReflectance = mix(vec3(f0), rawAlbedo, metalness);
        float fresnel = pow(clamp(1.0f + dot(newNormal, normalize(viewPos.xyz)), 0.0f, 1.0f), 5.0f);
        fresnel3 = mix(baseReflectance, vec3(1.0f), fresnel);
        if (f0 >= 0.9f && f0 < 1.0f) {
            baseReflectance = GetMetalCol(f0);
            fresnel3 = ComplexFresnel(pow(fresnel, 0.2f), f0);
        }
        float aoSquared = ao * ao;
        shadow *= aoSquared;
        fresnel3 *= aoSquared;
        albedo.rgb = albedo.rgb * (1.0f - fresnel3 * smoothness * smoothness * (1.0f - metalness));
        vec3 specularColor = GetSpecularColor(lightmap.y, metalness, baseReflectance);
        albedo.rgb += GetSpecularHighlight(newNormal, viewPos, smoothness, baseReflectance, specularColor, shadow * vanillaDiffuse, 1.0f);
        normalMap = mix(vec3(0.0f, 0.0f, 1.0f), normalMap, smoothness);
        newNormal = clamp(normalize(normalMap * tbnMatrix), vec3(-1.0f), vec3(1.0f));
        albedo.rgb = sqrt(max(albedo.rgb, vec3(0.0f)));
    }
    iris_FragData0 = albedo;
    iris_FragData1 = vec4(smoothness, skyOcclusion, 0.25f, 1.0f);
    iris_FragData2 = vec4(EncodeNormal(newNormal), float(gl_FragCoord.z < 1.0f), 1.0f);
    iris_FragData3 = vec4(fresnel3, 1.0f);
    if (!(iris_FragData0.a > iris_currentAlphaTest)) {
        discard;
    }
}
