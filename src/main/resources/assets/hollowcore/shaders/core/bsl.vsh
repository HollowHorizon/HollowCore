#version 330 core
// Generated by glsl-transformer

uniform mat4 iris_ProjMat;
in vec3 iris_Position;
uniform mat4 iris_ModelViewMatInverse;
uniform mat4 iris_ProjMatInverse;
uniform mat3 iris_NormalMat;
uniform mat4 iris_LightmapTextureMatrix;
uniform mat4 iris_TextureMat;
uniform mat4 iris_ModelViewMat;
in vec3 iris_Normal;
in vec4 iris_Color;
uniform vec4 iris_ColorModulator;
in ivec2 iris_UV2;
in vec2 iris_UV0;
uniform float iris_FogDensity;
uniform float iris_FogStart;
uniform float iris_FogEnd;
uniform vec4 iris_FogColor;

struct iris_FogParameters {
    vec4 color;
    float density;
    float start;
    float end;
    float scale;
};
iris_FogParameters iris_Fog = iris_FogParameters(iris_FogColor, iris_FogDensity, iris_FogStart, iris_FogEnd, 1.0f / (iris_FogEnd - iris_FogStart));

vec4 iris_FrontColor;
out float iris_FogFragCoord;
flat out ivec3 iris_entityInfo;
in ivec3 iris_Entity;
uniform sampler2D iris_overlay;
out vec4 entityColor;
out vec4 iris_vertexColor;
in ivec2 iris_UV1;

const int shadowMapResolution = 2048;
const float shadowDistance = 256.0f;
const float sunPathRotation = -40.0f;
const float shadowMapBias = 1.0f - 25.6f / shadowDistance;

out vec2 texCoord, lmCoord;
out vec3 normal;
out vec3 sunVec, upVec, eastVec;
out vec4 color;
out float dist;
out vec3 binormal, tangent;
out vec3 viewVector;
out vec4 vTexCoord, vTexCoordAM;

uniform int worldTime;
uniform float frameTimeCounter;
uniform float timeAngle;
uniform vec3 cameraPosition;
uniform mat4 gbufferModelView, gbufferModelViewInverse;

in vec4 mc_Entity;
in vec4 mc_midTexCoord;
in vec4 at_tangent;

float frametime = frameTimeCounter * 1.0f;
uniform vec3 iris_ChunkOffset;

mat4 _iris_internal_translate(vec3 offset) {
    return mat4(1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, offset.x, offset.y, offset.z, 1.0f);
}

vec4 ftransform() {
    return (iris_ProjMat * (iris_ModelViewMat * _iris_internal_translate(iris_ChunkOffset))) * vec4(iris_Position, 1.0f);
}

void main() {
    iris_FogFragCoord = 0.0f;
    iris_entityInfo = iris_Entity;
    vec4 overlayColor = texelFetch(iris_overlay, iris_UV1, 0);
    entityColor = vec4(overlayColor.rgb, 1.0f - overlayColor.a);
    iris_vertexColor = iris_Color;
    entityColor.rgb *= float(entityColor.a != 0.0f);
    texCoord = (iris_TextureMat * vec4(iris_UV0, 0.0f, 1.0f)).xy;
    lmCoord = (iris_LightmapTextureMatrix * vec4(iris_UV2, 0.0f, 1.0f)).xy;
    lmCoord = clamp((lmCoord - 0.03125f) * 1.06667f, vec2(0.0f), vec2(0.9333f, 1.0f));
    normal = normalize(iris_NormalMat * iris_Normal);
    tangent = normalize(iris_NormalMat * at_tangent.xyz);
    binormal = normalize(iris_NormalMat * cross(at_tangent.xyz, iris_Normal.xyz) * at_tangent.w);
    mat3 tbnMatrix = mat3(tangent.x, binormal.x, normal.x, tangent.y, binormal.y, normal.y, tangent.z, binormal.z, normal.z);
    viewVector = tbnMatrix * ((iris_ModelViewMat * _iris_internal_translate(iris_ChunkOffset)) * vec4(iris_Position, 1.0f)).xyz;
    dist = length((iris_ModelViewMat * _iris_internal_translate(iris_ChunkOffset)) * vec4(iris_Position, 1.0f));
    vec2 midCoord = (iris_TextureMat * mc_midTexCoord).st;
    vec2 texMinMidCoord = texCoord - midCoord;
    vTexCoordAM.pq = abs(texMinMidCoord) * 2;
    vTexCoordAM.st = min(texCoord, midCoord - texMinMidCoord);
    vTexCoord.xy = sign(texMinMidCoord) * 0.5f + 0.5f;
    color = (iris_Color * iris_ColorModulator);
    const vec2 sunRotationData = vec2(cos(sunPathRotation * 0.01745329251994f), -sin(sunPathRotation * 0.01745329251994f));
    float ang = fract(timeAngle - 0.25f);
    ang = (ang + (cos(ang * 3.14159265358979f) * -0.5f + 0.5f - ang) / 3.0f) * 6.28318530717959f;
    sunVec = normalize((gbufferModelView * vec4(vec3(-sin(ang), cos(ang) * sunRotationData) * 2000.0f, 1.0f)).xyz);
    upVec = normalize(gbufferModelView[1].xyz);
    eastVec = normalize(gbufferModelView[0].xyz);
    gl_Position = ftransform();
}
